package logicline.modeleSemantique;

import java.util.*;

public class ListeClauses {
    public ListeClauses()
    {
        clauses = new LinkedList<Clause>();
    }

    public String toString()
    {
        if (clauses.size() == 0)
          return "⊤"; 

        String s = "";
        ListIterator<Clause> it = clauses.listIterator();
        s += it.next().toString();
        while(it.hasNext())
            s += " ∧ " + it.next().toString(); 
        return s; 
    }

    public void add(Clause c)
    {
        clauses.add(c);
    }

    public void addAll(ListeClauses l)
    {
        clauses.addAll(l.clauses);
    }

    public Clause get(int i)
    {
        return clauses.get(i);
    }

    public ListeClauses simplifieClause(String litteral, boolean valeur) throws NotSatisfiableException
    {
        
        Iterator<Clause> it = this.clauses.iterator();
        ListeClauses simple = new ListeClauses();
        
        while (it.hasNext()) {
        	
        	Clause c = it.next();
        	
        	String unit = c.clauseUnitaire();
        	Boolean tmp = c.get(litteral);
        	
        	if (unit == litteral && tmp != null && tmp != valeur) {
        			
        			throw new NotSatisfiableException();
        	}
        	
        	if (tmp != null && tmp != valeur) {
        			c.remove(litteral);
        			simple.add(c);
        	}
        	
        	else {
        		it.remove();
        	}
        	
        	if (tmp == null) {
        		simple.add(c);
        
        	}
        }
        
        return simple;
        
        
    }

    public Substitution dpll() throws NotSatisfiableException
    {
        
        Substitution s = new Substitution();
        
        //elimination des clauses unitaires 
        
        Iterator<Clause> itUnitaire = this.clauses.iterator();
        while (itUnitaire.hasNext()) {
        	
        	Clause c = itUnitaire.next();
        	String lit = c.clauseUnitaire();
        	Boolean val = c.get(lit);
        	
        	if (lit != null ) {
        		s.addAll(this.simplifieClause(lit, val).dpll());
        		s.set(lit, new Constante(val));
        	}
        }
        
        //elimination des litteraux purs
        Iterator<Clause> itPur = this.clauses.iterator();
        while (itPur.hasNext()) {
        	
        	Clause c = itPur.next();
        	Clause ctmp = new Clause(c);
        	Boolean trouve = false;
        	String tmp = null;
        	
        	try {
        		tmp = ctmp.premierLitteral();
        	}
        	catch (NoSuchElementException e) {
        			
        	}
        	
        	while (tmp != null && !trouve ) {
        		ctmp.remove(tmp);
        		
        		Boolean pur = true;
        		Boolean val = c.get(tmp);
        	
        		if(c.litterauxPositifs().contains(tmp)) {
        		
        			for (Clause x : this.clauses) {
        				if (x.litterauxNegatifs().contains(tmp)) {
        					pur = false;
        					break;
        				}
        			}
        		}
        	
        		else if (c.litterauxNegatifs().contains(tmp)) {
        			for (Clause x : this.clauses) {
        				if (x.litterauxPositifs().contains(tmp)) {
        					pur = false;
        					break;
        				}
        			}
        		}
        	
        		if (pur) {
        			s.addAll(this.simplifieClause(tmp, val).dpll());
        			s.set(tmp, new Constante(val));	
        			trouve = true;
        		}
        		
        		try {
            		tmp = ctmp.premierLitteral(); 
            	}
            	catch (NoSuchElementException e) {
            			tmp = null;
            	}
        		
        	}
        }
        	
        //Resultante
        Iterator<Clause> itRes = this.clauses.iterator();
        while (itRes.hasNext()) {
        		
        	Boolean trouve = false;
        	Clause c = itRes.next();
        	Clause ctmp  = new Clause(c);
        	String tmp = null;
        	
        	try {
        		tmp = ctmp.premierLitteral();
        	}
        	catch (NoSuchElementException e) {
        	}
    		
        		while (tmp != null && !trouve) {
        			
        			ctmp.remove(tmp);
    			
        			Boolean signe = c.litterauxPositifs().contains(tmp);
        			ListeClauses copy1 = new  ListeClauses();
        			ListeClauses copy2 = new ListeClauses();
    			
        			if (signe != null) {
    			
        				for (Clause x : this.clauses) {
        					if (x.litterauxPositifs().contains(tmp) == signe ) {
        						copy1.add(x);
        					}
        					else {
        						copy2.add(x);
        					}
        				}
        			}
    			
        			try {
        				ListClauses ex = copy1.simplifieClause(tmp, !signe);
        				s.addAll(ex.dpll());
        				s.set(tmp,new Constante(!signe));
        				trouve = true;
        			}
        			catch (NotSatisfiableException e) {
        				s.addAll(copy2.simplifieClause(tmp, signe).dpll());
        				s.set(tmp, new Constante(signe));
        				trouve = true;
        			}
    			
        			try {
        				tmp = ctmp.premierLitteral(); 
        			}
        			catch (NoSuchElementException e) {
            				tmp = null;
        			}
        		
        		}
        }
    		return s;
     }

    private List<Clause> clauses;
}
